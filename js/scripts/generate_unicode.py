#!/usr/bin/env python3

# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT license.


import icu
from typing import IO


def escape(cp: int) -> str:
    if cp < 0x10000:
        return f"\\u{cp:04x}"
    else:
        return f"\\u{{{cp:x}}}"


def gen_boundary_regex(normalizer: icu.Normalizer2) -> str:
    ranges = []
    for cp in range(0x110000):
        if not normalizer.hasBoundaryBefore(chr(cp)):
            if ranges and cp == ranges[-1].stop:
                ranges[-1] = range(ranges[-1].start, cp + 1)
            else:
                ranges.append(range(cp, cp + 1))

    chunks = ['/.[']
    for r in ranges:
        chunks.append(escape(r.start))
        if len(r) > 1:
            chunks.append('-')
            chunks.append(escape(r.stop - 1))
    chunks.append(']*/gsu')

    return "".join(chunks)


def export_boundary_regex(f: IO[str], form: str) -> None:
    f.write(f'/**\n')
    f.write(f' * Matches until the next {form} normalization boundary.\n')
    f.write(f' */\n')
    f.write(f'export const {form}_CHUNK = ')

    normalizer = getattr(icu.Normalizer2, "get" + form + "Instance")()
    f.write(gen_boundary_regex(normalizer))
    f.write(';\n')


if __name__ == "__main__":
    with open('src/unicode.ts', 'w') as f:
        f.write('/**\n')
        f.write(' * GENERATED BY scripts/generate_unicode.py.\n')
        f.write(' * DO NOT EDIT BY HAND.\n')
        f.write(' */\n\n')

        export_boundary_regex(f, "NFC")
        f.write('\n')
        export_boundary_regex(f, "NFD")
        f.write('\n')
        export_boundary_regex(f, "NFKC")
        f.write('\n')
        export_boundary_regex(f, "NFKD")
